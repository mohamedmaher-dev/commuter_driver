// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_commute_pickup_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddCommutePickupEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(LatLng latLng, Placemark placemark) setLocation,
    required TResult Function(Set<int> range) changeRange,
    required TResult Function(DateTime? time) setStartTime,
    required TResult Function(DateTime? time) setEndTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult? Function(Set<int> range)? changeRange,
    TResult? Function(DateTime? time)? setStartTime,
    TResult? Function(DateTime? time)? setEndTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult Function(Set<int> range)? changeRange,
    TResult Function(DateTime? time)? setStartTime,
    TResult Function(DateTime? time)? setEndTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(SetLocation value) setLocation,
    required TResult Function(ChangeRange value) changeRange,
    required TResult Function(SetStartTime value) setStartTime,
    required TResult Function(SetEndTime value) setEndTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(SetLocation value)? setLocation,
    TResult? Function(ChangeRange value)? changeRange,
    TResult? Function(SetStartTime value)? setStartTime,
    TResult? Function(SetEndTime value)? setEndTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(SetLocation value)? setLocation,
    TResult Function(ChangeRange value)? changeRange,
    TResult Function(SetStartTime value)? setStartTime,
    TResult Function(SetEndTime value)? setEndTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddCommutePickupEventCopyWith<$Res> {
  factory $AddCommutePickupEventCopyWith(AddCommutePickupEvent value,
          $Res Function(AddCommutePickupEvent) then) =
      _$AddCommutePickupEventCopyWithImpl<$Res, AddCommutePickupEvent>;
}

/// @nodoc
class _$AddCommutePickupEventCopyWithImpl<$Res,
        $Val extends AddCommutePickupEvent>
    implements $AddCommutePickupEventCopyWith<$Res> {
  _$AddCommutePickupEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$AddCommutePickupEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'AddCommutePickupEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(LatLng latLng, Placemark placemark) setLocation,
    required TResult Function(Set<int> range) changeRange,
    required TResult Function(DateTime? time) setStartTime,
    required TResult Function(DateTime? time) setEndTime,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult? Function(Set<int> range)? changeRange,
    TResult? Function(DateTime? time)? setStartTime,
    TResult? Function(DateTime? time)? setEndTime,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult Function(Set<int> range)? changeRange,
    TResult Function(DateTime? time)? setStartTime,
    TResult Function(DateTime? time)? setEndTime,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(SetLocation value) setLocation,
    required TResult Function(ChangeRange value) changeRange,
    required TResult Function(SetStartTime value) setStartTime,
    required TResult Function(SetEndTime value) setEndTime,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(SetLocation value)? setLocation,
    TResult? Function(ChangeRange value)? changeRange,
    TResult? Function(SetStartTime value)? setStartTime,
    TResult? Function(SetEndTime value)? setEndTime,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(SetLocation value)? setLocation,
    TResult Function(ChangeRange value)? changeRange,
    TResult Function(SetStartTime value)? setStartTime,
    TResult Function(SetEndTime value)? setEndTime,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements AddCommutePickupEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$SetLocationImplCopyWith<$Res> {
  factory _$$SetLocationImplCopyWith(
          _$SetLocationImpl value, $Res Function(_$SetLocationImpl) then) =
      __$$SetLocationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LatLng latLng, Placemark placemark});
}

/// @nodoc
class __$$SetLocationImplCopyWithImpl<$Res>
    extends _$AddCommutePickupEventCopyWithImpl<$Res, _$SetLocationImpl>
    implements _$$SetLocationImplCopyWith<$Res> {
  __$$SetLocationImplCopyWithImpl(
      _$SetLocationImpl _value, $Res Function(_$SetLocationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latLng = null,
    Object? placemark = null,
  }) {
    return _then(_$SetLocationImpl(
      latLng: null == latLng
          ? _value.latLng
          : latLng // ignore: cast_nullable_to_non_nullable
              as LatLng,
      placemark: null == placemark
          ? _value.placemark
          : placemark // ignore: cast_nullable_to_non_nullable
              as Placemark,
    ));
  }
}

/// @nodoc

class _$SetLocationImpl implements SetLocation {
  const _$SetLocationImpl({required this.latLng, required this.placemark});

  @override
  final LatLng latLng;
  @override
  final Placemark placemark;

  @override
  String toString() {
    return 'AddCommutePickupEvent.setLocation(latLng: $latLng, placemark: $placemark)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetLocationImpl &&
            (identical(other.latLng, latLng) || other.latLng == latLng) &&
            (identical(other.placemark, placemark) ||
                other.placemark == placemark));
  }

  @override
  int get hashCode => Object.hash(runtimeType, latLng, placemark);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetLocationImplCopyWith<_$SetLocationImpl> get copyWith =>
      __$$SetLocationImplCopyWithImpl<_$SetLocationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(LatLng latLng, Placemark placemark) setLocation,
    required TResult Function(Set<int> range) changeRange,
    required TResult Function(DateTime? time) setStartTime,
    required TResult Function(DateTime? time) setEndTime,
  }) {
    return setLocation(latLng, placemark);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult? Function(Set<int> range)? changeRange,
    TResult? Function(DateTime? time)? setStartTime,
    TResult? Function(DateTime? time)? setEndTime,
  }) {
    return setLocation?.call(latLng, placemark);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult Function(Set<int> range)? changeRange,
    TResult Function(DateTime? time)? setStartTime,
    TResult Function(DateTime? time)? setEndTime,
    required TResult orElse(),
  }) {
    if (setLocation != null) {
      return setLocation(latLng, placemark);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(SetLocation value) setLocation,
    required TResult Function(ChangeRange value) changeRange,
    required TResult Function(SetStartTime value) setStartTime,
    required TResult Function(SetEndTime value) setEndTime,
  }) {
    return setLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(SetLocation value)? setLocation,
    TResult? Function(ChangeRange value)? changeRange,
    TResult? Function(SetStartTime value)? setStartTime,
    TResult? Function(SetEndTime value)? setEndTime,
  }) {
    return setLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(SetLocation value)? setLocation,
    TResult Function(ChangeRange value)? changeRange,
    TResult Function(SetStartTime value)? setStartTime,
    TResult Function(SetEndTime value)? setEndTime,
    required TResult orElse(),
  }) {
    if (setLocation != null) {
      return setLocation(this);
    }
    return orElse();
  }
}

abstract class SetLocation implements AddCommutePickupEvent {
  const factory SetLocation(
      {required final LatLng latLng,
      required final Placemark placemark}) = _$SetLocationImpl;

  LatLng get latLng;
  Placemark get placemark;
  @JsonKey(ignore: true)
  _$$SetLocationImplCopyWith<_$SetLocationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeRangeImplCopyWith<$Res> {
  factory _$$ChangeRangeImplCopyWith(
          _$ChangeRangeImpl value, $Res Function(_$ChangeRangeImpl) then) =
      __$$ChangeRangeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Set<int> range});
}

/// @nodoc
class __$$ChangeRangeImplCopyWithImpl<$Res>
    extends _$AddCommutePickupEventCopyWithImpl<$Res, _$ChangeRangeImpl>
    implements _$$ChangeRangeImplCopyWith<$Res> {
  __$$ChangeRangeImplCopyWithImpl(
      _$ChangeRangeImpl _value, $Res Function(_$ChangeRangeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? range = null,
  }) {
    return _then(_$ChangeRangeImpl(
      range: null == range
          ? _value._range
          : range // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ));
  }
}

/// @nodoc

class _$ChangeRangeImpl implements ChangeRange {
  const _$ChangeRangeImpl({required final Set<int> range}) : _range = range;

  final Set<int> _range;
  @override
  Set<int> get range {
    if (_range is EqualUnmodifiableSetView) return _range;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_range);
  }

  @override
  String toString() {
    return 'AddCommutePickupEvent.changeRange(range: $range)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeRangeImpl &&
            const DeepCollectionEquality().equals(other._range, _range));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_range));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeRangeImplCopyWith<_$ChangeRangeImpl> get copyWith =>
      __$$ChangeRangeImplCopyWithImpl<_$ChangeRangeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(LatLng latLng, Placemark placemark) setLocation,
    required TResult Function(Set<int> range) changeRange,
    required TResult Function(DateTime? time) setStartTime,
    required TResult Function(DateTime? time) setEndTime,
  }) {
    return changeRange(range);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult? Function(Set<int> range)? changeRange,
    TResult? Function(DateTime? time)? setStartTime,
    TResult? Function(DateTime? time)? setEndTime,
  }) {
    return changeRange?.call(range);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult Function(Set<int> range)? changeRange,
    TResult Function(DateTime? time)? setStartTime,
    TResult Function(DateTime? time)? setEndTime,
    required TResult orElse(),
  }) {
    if (changeRange != null) {
      return changeRange(range);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(SetLocation value) setLocation,
    required TResult Function(ChangeRange value) changeRange,
    required TResult Function(SetStartTime value) setStartTime,
    required TResult Function(SetEndTime value) setEndTime,
  }) {
    return changeRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(SetLocation value)? setLocation,
    TResult? Function(ChangeRange value)? changeRange,
    TResult? Function(SetStartTime value)? setStartTime,
    TResult? Function(SetEndTime value)? setEndTime,
  }) {
    return changeRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(SetLocation value)? setLocation,
    TResult Function(ChangeRange value)? changeRange,
    TResult Function(SetStartTime value)? setStartTime,
    TResult Function(SetEndTime value)? setEndTime,
    required TResult orElse(),
  }) {
    if (changeRange != null) {
      return changeRange(this);
    }
    return orElse();
  }
}

abstract class ChangeRange implements AddCommutePickupEvent {
  const factory ChangeRange({required final Set<int> range}) =
      _$ChangeRangeImpl;

  Set<int> get range;
  @JsonKey(ignore: true)
  _$$ChangeRangeImplCopyWith<_$ChangeRangeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SetStartTimeImplCopyWith<$Res> {
  factory _$$SetStartTimeImplCopyWith(
          _$SetStartTimeImpl value, $Res Function(_$SetStartTimeImpl) then) =
      __$$SetStartTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime? time});
}

/// @nodoc
class __$$SetStartTimeImplCopyWithImpl<$Res>
    extends _$AddCommutePickupEventCopyWithImpl<$Res, _$SetStartTimeImpl>
    implements _$$SetStartTimeImplCopyWith<$Res> {
  __$$SetStartTimeImplCopyWithImpl(
      _$SetStartTimeImpl _value, $Res Function(_$SetStartTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? time = freezed,
  }) {
    return _then(_$SetStartTimeImpl(
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$SetStartTimeImpl implements SetStartTime {
  const _$SetStartTimeImpl({required this.time});

  @override
  final DateTime? time;

  @override
  String toString() {
    return 'AddCommutePickupEvent.setStartTime(time: $time)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetStartTimeImpl &&
            (identical(other.time, time) || other.time == time));
  }

  @override
  int get hashCode => Object.hash(runtimeType, time);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetStartTimeImplCopyWith<_$SetStartTimeImpl> get copyWith =>
      __$$SetStartTimeImplCopyWithImpl<_$SetStartTimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(LatLng latLng, Placemark placemark) setLocation,
    required TResult Function(Set<int> range) changeRange,
    required TResult Function(DateTime? time) setStartTime,
    required TResult Function(DateTime? time) setEndTime,
  }) {
    return setStartTime(time);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult? Function(Set<int> range)? changeRange,
    TResult? Function(DateTime? time)? setStartTime,
    TResult? Function(DateTime? time)? setEndTime,
  }) {
    return setStartTime?.call(time);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult Function(Set<int> range)? changeRange,
    TResult Function(DateTime? time)? setStartTime,
    TResult Function(DateTime? time)? setEndTime,
    required TResult orElse(),
  }) {
    if (setStartTime != null) {
      return setStartTime(time);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(SetLocation value) setLocation,
    required TResult Function(ChangeRange value) changeRange,
    required TResult Function(SetStartTime value) setStartTime,
    required TResult Function(SetEndTime value) setEndTime,
  }) {
    return setStartTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(SetLocation value)? setLocation,
    TResult? Function(ChangeRange value)? changeRange,
    TResult? Function(SetStartTime value)? setStartTime,
    TResult? Function(SetEndTime value)? setEndTime,
  }) {
    return setStartTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(SetLocation value)? setLocation,
    TResult Function(ChangeRange value)? changeRange,
    TResult Function(SetStartTime value)? setStartTime,
    TResult Function(SetEndTime value)? setEndTime,
    required TResult orElse(),
  }) {
    if (setStartTime != null) {
      return setStartTime(this);
    }
    return orElse();
  }
}

abstract class SetStartTime implements AddCommutePickupEvent {
  const factory SetStartTime({required final DateTime? time}) =
      _$SetStartTimeImpl;

  DateTime? get time;
  @JsonKey(ignore: true)
  _$$SetStartTimeImplCopyWith<_$SetStartTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SetEndTimeImplCopyWith<$Res> {
  factory _$$SetEndTimeImplCopyWith(
          _$SetEndTimeImpl value, $Res Function(_$SetEndTimeImpl) then) =
      __$$SetEndTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime? time});
}

/// @nodoc
class __$$SetEndTimeImplCopyWithImpl<$Res>
    extends _$AddCommutePickupEventCopyWithImpl<$Res, _$SetEndTimeImpl>
    implements _$$SetEndTimeImplCopyWith<$Res> {
  __$$SetEndTimeImplCopyWithImpl(
      _$SetEndTimeImpl _value, $Res Function(_$SetEndTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? time = freezed,
  }) {
    return _then(_$SetEndTimeImpl(
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$SetEndTimeImpl implements SetEndTime {
  const _$SetEndTimeImpl({required this.time});

  @override
  final DateTime? time;

  @override
  String toString() {
    return 'AddCommutePickupEvent.setEndTime(time: $time)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetEndTimeImpl &&
            (identical(other.time, time) || other.time == time));
  }

  @override
  int get hashCode => Object.hash(runtimeType, time);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetEndTimeImplCopyWith<_$SetEndTimeImpl> get copyWith =>
      __$$SetEndTimeImplCopyWithImpl<_$SetEndTimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(LatLng latLng, Placemark placemark) setLocation,
    required TResult Function(Set<int> range) changeRange,
    required TResult Function(DateTime? time) setStartTime,
    required TResult Function(DateTime? time) setEndTime,
  }) {
    return setEndTime(time);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult? Function(Set<int> range)? changeRange,
    TResult? Function(DateTime? time)? setStartTime,
    TResult? Function(DateTime? time)? setEndTime,
  }) {
    return setEndTime?.call(time);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(LatLng latLng, Placemark placemark)? setLocation,
    TResult Function(Set<int> range)? changeRange,
    TResult Function(DateTime? time)? setStartTime,
    TResult Function(DateTime? time)? setEndTime,
    required TResult orElse(),
  }) {
    if (setEndTime != null) {
      return setEndTime(time);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(SetLocation value) setLocation,
    required TResult Function(ChangeRange value) changeRange,
    required TResult Function(SetStartTime value) setStartTime,
    required TResult Function(SetEndTime value) setEndTime,
  }) {
    return setEndTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(SetLocation value)? setLocation,
    TResult? Function(ChangeRange value)? changeRange,
    TResult? Function(SetStartTime value)? setStartTime,
    TResult? Function(SetEndTime value)? setEndTime,
  }) {
    return setEndTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(SetLocation value)? setLocation,
    TResult Function(ChangeRange value)? changeRange,
    TResult Function(SetStartTime value)? setStartTime,
    TResult Function(SetEndTime value)? setEndTime,
    required TResult orElse(),
  }) {
    if (setEndTime != null) {
      return setEndTime(this);
    }
    return orElse();
  }
}

abstract class SetEndTime implements AddCommutePickupEvent {
  const factory SetEndTime({required final DateTime? time}) = _$SetEndTimeImpl;

  DateTime? get time;
  @JsonKey(ignore: true)
  _$$SetEndTimeImplCopyWith<_$SetEndTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddCommutePickupState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(int id) refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(int id)? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(int id)? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Refresh value) refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Refresh value)? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Refresh value)? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddCommutePickupStateCopyWith<$Res> {
  factory $AddCommutePickupStateCopyWith(AddCommutePickupState value,
          $Res Function(AddCommutePickupState) then) =
      _$AddCommutePickupStateCopyWithImpl<$Res, AddCommutePickupState>;
}

/// @nodoc
class _$AddCommutePickupStateCopyWithImpl<$Res,
        $Val extends AddCommutePickupState>
    implements $AddCommutePickupStateCopyWith<$Res> {
  _$AddCommutePickupStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$AddCommutePickupStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'AddCommutePickupState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(int id) refresh,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(int id)? refresh,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(int id)? refresh,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Refresh value) refresh,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Refresh value)? refresh,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Refresh value)? refresh,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements AddCommutePickupState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$RefreshImplCopyWith<$Res> {
  factory _$$RefreshImplCopyWith(
          _$RefreshImpl value, $Res Function(_$RefreshImpl) then) =
      __$$RefreshImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int id});
}

/// @nodoc
class __$$RefreshImplCopyWithImpl<$Res>
    extends _$AddCommutePickupStateCopyWithImpl<$Res, _$RefreshImpl>
    implements _$$RefreshImplCopyWith<$Res> {
  __$$RefreshImplCopyWithImpl(
      _$RefreshImpl _value, $Res Function(_$RefreshImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$RefreshImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$RefreshImpl implements Refresh {
  const _$RefreshImpl(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'AddCommutePickupState.refresh(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RefreshImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RefreshImplCopyWith<_$RefreshImpl> get copyWith =>
      __$$RefreshImplCopyWithImpl<_$RefreshImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(int id) refresh,
  }) {
    return refresh(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(int id)? refresh,
  }) {
    return refresh?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(int id)? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(Refresh value) refresh,
  }) {
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(Refresh value)? refresh,
  }) {
    return refresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(Refresh value)? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class Refresh implements AddCommutePickupState {
  const factory Refresh(final int id) = _$RefreshImpl;

  int get id;
  @JsonKey(ignore: true)
  _$$RefreshImplCopyWith<_$RefreshImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
